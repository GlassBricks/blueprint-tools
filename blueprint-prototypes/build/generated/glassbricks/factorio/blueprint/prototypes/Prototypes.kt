// Generated by prototype-codegen
@file:Suppress(
    "EnumEntryName",
    "PropertyName",
)
@file:UseSerializers(
    PositionShorthandSerializer::class,
    BoundingBoxShorthandSerializer::class,
    LuaListSerializer::class,
)

package glassbricks.factorio.blueprint.prototypes

import glassbricks.factorio.blueprint.BoundingBox
import glassbricks.factorio.blueprint.Direction
import glassbricks.factorio.blueprint.Position
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.UseSerializers

/**
 * The abstract base for prototypes. PrototypeBase defines the common features of prototypes, such
 * as localization and order.
 */
@Serializable
public sealed class PrototypeBase {
    /**
     * Specifies the kind of prototype this is.
     *
     * For a list of all types used in vanilla, see [data.raw](https://wiki.factorio.com/Data.raw).
     */
    public lateinit var type: String
        private set

    /**
     * Unique textual identification of the prototype. May not contain a dot, nor exceed a length of
     * 200 characters.
     *
     * For a list of all names used in vanilla, see [data.raw](https://wiki.factorio.com/Data.raw).
     */
    public lateinit var name: String
        private set
}

/**
 * Abstract base of all entities in the game. Entity is nearly everything that can be on the map
 * (except tiles).
 *
 * For in game script access to entity, take a look at [LuaEntity](runtime:LuaEntity).
 */
@Serializable
public sealed class EntityPrototype : PrototypeBase() {
    /**
     * Specification of the entity collision boundaries. Empty collision box means no collision and
     * is used for smoke, projectiles, particles, explosions etc.
     *
     * The `{0,0}` coordinate in the collision box will match the entity position. It should be near
     * the center of the collision box, to keep correct entity drawing order. The bounding box must
     * include the `{0,0}` coordinate.
     *
     * Note, that for buildings, it is customary to leave 0.1 wide border between the edge of the
     * tile and the edge of the building, this lets the player move between the building and electric
     * poles/inserters etc.
     */
    public var collision_box: BoundingBox? = null
        private set

    /**
     * Two entities can collide only if they share a layer from the collision mask.
     */
    public var collision_mask: CollisionMask? = null
        private set

    public var flags: EntityPrototypeFlags? = null
        private set

    /**
     * Supported values are 1 (for 1x1 grid) and 2 (for 2x2 grid, like rails).
     *
     * Internally forced to be `2` for [RailPrototype](prototype:RailPrototype),
     * [RailRemnantsPrototype](prototype:RailRemnantsPrototype) and
     * [TrainStopPrototype](prototype:TrainStopPrototype).
     */
    public var build_grid_size: UByte? = null
        private set

    /**
     * Item that when placed creates this entity. Determines which item is picked when "Q" (smart
     * pipette) is used on this entity. Determines which item and item amount is needed in a blueprint
     * of this entity and to revive a ghost of this entity.
     *
     * The item count specified here can't be larger than the stack size of that item.
     */
    public var placeable_by: ItemOrArray<ItemToPlace>? = null
        private set

    /**
     * Used to determine how the center of the entity should be positioned when building (unless the
     * off-grid [flag](prototype:EntityPrototypeFlags) is specified).
     *
     * When the tile width is odd, the center will be in the center of the tile, when it is even,
     * the center is on the tile transition.
     */
    public var tile_width: UInt? = null
        private set

    public var tile_height: UInt? = null
        private set
}

/**
 * Abstract base of all entities with health in the game.
 */
@Serializable
public sealed class EntityWithHealthPrototype : EntityPrototype()

/**
 * Abstract base of all entities with a force in the game. These entities have a
 * [LuaEntity::unit_number](runtime:LuaEntity::unit_number) during runtime. Can be high priority
 * [military targets](https://wiki.factorio.com/Military_units_and_structures).
 */
@Serializable
public sealed class EntityWithOwnerPrototype : EntityWithHealthPrototype()

/**
 * Entity with energy source with specialised animation for charging/discharging. Used for the
 * [accumulator](https://wiki.factorio.com/Accumulator) entity.
 */
@Serializable
@SerialName("accumulator")
public class AccumulatorPrototype : EntityWithOwnerPrototype() {
    /**
     * The capacity of the energy source buffer specifies the capacity of the accumulator.
     */
    public lateinit var energy_source: ElectricEnergySource
        private set

    /**
     * The maximum circuit wire distance for this entity.
     */
    public var circuit_wire_max_distance: Double? = null
        private set

    /**
     * The name of the signal that is the default for when an accumulator is connected to the
     * circuit network.
     */
    public var default_output_signal: SignalIDConnector? = null
        private set
}

/**
 * Abstract base type for decider and arithmetic combinators.
 */
@Serializable
public sealed class CombinatorPrototype : EntityWithOwnerPrototype() {
    public lateinit var energy_source: EVEnergySource
        private set

    /**
     * The maximum circuit wire distance for this entity.
     */
    public var circuit_wire_max_distance: Double? = null
        private set
}

/**
 * An [arithmetic combinator](https://wiki.factorio.com/Arithmetic_combinator).
 */
@Serializable
@SerialName("arithmetic-combinator")
public class ArithmeticCombinatorPrototype : CombinatorPrototype()

/**
 * An [artillery turret](https://wiki.factorio.com/Artillery_turret).
 */
@Serializable
@SerialName("artillery-turret")
public class ArtilleryTurretPrototype : EntityWithOwnerPrototype()

/**
 * The abstract basis of the assembling machines and furnaces. Contains the properties that both of
 * them have.
 *
 * Note that a crafting machine cannot be rotated unless it has at least one of the following: a
 * fluid box, a heat energy source, a fluid energy source, or a non-square collision box. Crafting
 * machines with non-square collision boxes can only be rotated before placement, not after.
 */
@Serializable
public sealed class CraftingMachinePrototype : EntityWithOwnerPrototype() {
    /**
     * How fast this crafting machine can craft. 1 means that for example a 1 second long recipe
     * take 1 second to craft. 0.5 means it takes 2 seconds, and 2 means it takes 0.5 seconds.
     *
     * Crafting speed has to be positive.
     */
    public var crafting_speed: Double = 0.0
        private set

    /**
     * A list of [recipe categories](prototype:RecipeCategory) this crafting machine can use.
     */
    public lateinit var crafting_categories: List<RecipeCategoryID>
        private set

    /**
     * Defines how the crafting machine is powered.
     *
     * When using an electric energy source and `drain` is not specified, it will be set to
     * `energy_usage รท 30` automatically.
     */
    public lateinit var energy_source: EnergySource
        private set

    /**
     * Can have `off_when_no_fluid_recipe` key that has a [bool](prototype:bool) value.
     * `off_when_no_fluid_recipe` defaults to false. `off_when_no_fluid_recipe` is ignored by
     * [FurnacePrototype](prototype:FurnacePrototype) and considered to always be false.
     *
     * If a crafting machine has fluid boxes *and* `off_when_no_fluid_recipe` is true, the crafting
     * machine can only be rotated when a recipe consuming or producing fluid is set, or it has one of
     * the other properties listed at the top of the page.
     */
    public var fluid_boxes: List<FluidBox>? = null
        private set

    /**
     * Sets the [modules](prototype:ModulePrototype) and [beacon](prototype:BeaconPrototype) effects
     * that are allowed to be used on this machine.
     *
     * Note: If the time to complete a recipe is shorter than one tick, only one craft can be
     * completed per tick, but productivity bonus is applied to the non-limited ''completable'' work.
     * For a simple example, if a recipe were to take half a tick, only one recipe would be completed,
     * but twice the productivity bonus would occur. The surplus production from productivity is
     * **not** limited to one craft per tick.
     */
    public var allowed_effects: EffectTypeLimitation? = null
        private set

    /**
     * Productivity bonus that this machine always has.
     */
    public var base_productivity: Float? = null
        private set

    /**
     * The number of module slots in this machine, and their icon positions.
     */
    public var module_specification: ModuleSpecification? = null
        private set
}

/**
 * An assembling machine - like the assembling machines 1/2/3 in the game, but you can use your own
 * recipe categories.
 */
@Serializable
@SerialName("assembling-machine")
public open class AssemblingMachinePrototype : CraftingMachinePrototype() {
    /**
     * The preset recipe of this machine. This machine does not show a recipe selection if this is
     * set. The base game uses this for the [rocket silo](https://wiki.factorio.com/Rocket_silo).
     */
    public var fixed_recipe: RecipeID? = null
        private set

    /**
     * Sets the maximum number of ingredients this machine can craft with. Any recipe with more
     * ingredients than this will be unavailable in this machine.
     *
     * This only counts item ingredients, not fluid ingredients! This means if ingredient count is
     * 2, and the recipe has 2 item ingredients and 1 fluid ingredient, it can still be crafted in the
     * machine.
     */
    public var ingredient_count: UByte? = null
        private set
}

/**
 * Entity with the ability to transfer [module](prototype:ModulePrototype) effects to its
 * neighboring entities.
 */
@Serializable
@SerialName("beacon")
public class BeaconPrototype : EntityWithOwnerPrototype() {
    public lateinit var energy_source: EVEnergySource
        private set

    /**
     * The maximum distance that this beacon can supply its neighbors with its module's effects. Max
     * distance is 64.
     */
    public var supply_area_distance: Double = 0.0
        private set

    /**
     * The multiplier of the module's effects, when shared between neighbors.
     */
    public var distribution_effectivity: Double = 0.0
        private set

    /**
     * The number of module slots in this beacon and their icon positions.
     */
    public lateinit var module_specification: ModuleSpecification
        private set

    /**
     * The types of [modules](prototype:ModulePrototype) that a player can place inside of the
     * beacon.
     */
    public var allowed_effects: EffectTypeLimitation? = null
        private set
}

/**
 * A [boiler](https://wiki.factorio.com/Boiler). It heats fluid and optionally outputs it as a
 * different fluid.
 */
@Serializable
@SerialName("boiler")
public class BoilerPrototype : EntityWithOwnerPrototype() {
    public lateinit var energy_source: EnergySource
        private set

    /**
     * The input fluid box.
     *
     * If `mode` is `"heat-water-inside"`, the fluid is heated up directly in this fluidbox.
     */
    public lateinit var fluid_box: FluidBox
        private set

    /**
     * The output fluid box.
     *
     * If `mode` is `"output-to-separate-pipe"` and this has a [filter](prototype:FluidBox::filter),
     * the heated input fluid is converted to the output fluid that is set in the filter (in a 1:1
     * ratio).
     *
     * If `mode` is `"heat-water-inside"`, this fluidbox is unused.
     */
    public lateinit var output_fluid_box: FluidBox
        private set
}

/**
 * An entity that produces power from a burner energy source.
 */
@Serializable
@SerialName("burner-generator")
public class BurnerGeneratorPrototype : EntityWithOwnerPrototype() {
    /**
     * The output energy source of the generator. Any emissions specified on this energy source are
     * ignored, they must be specified on `burner`.
     */
    public lateinit var energy_source: ElectricEnergySource
        private set

    /**
     * The input energy source of the generator.
     */
    public lateinit var burner: BurnerEnergySource
        private set
}

/**
 * A [constant combinator](https://wiki.factorio.com/Constant_combinator).
 */
@Serializable
@SerialName("constant-combinator")
public class ConstantCombinatorPrototype : EntityWithOwnerPrototype() {
    public var item_slot_count: UInt = 0u
        private set

    /**
     * The maximum circuit wire distance for this entity.
     */
    public var circuit_wire_max_distance: Double? = null
        private set
}

/**
 * A generic container, such as a chest. Cannot be rotated.
 */
@Serializable
public enum class InventoryType {
    with_bar,
    with_filters_and_bar,
}

/**
 * A generic container, such as a chest. Cannot be rotated.
 */
@Serializable
@SerialName("container")
public open class ContainerPrototype : EntityWithOwnerPrototype() {
    /**
     * The number of slots in this container.
     */
    public var inventory_size: ItemStackIndex = 0u
        private set

    /**
     * Whether the inventory of this container can be filtered (like cargo wagons) or not.
     */
    public var inventory_type: InventoryType? = null
        private set

    /**
     * The maximum circuit wire distance for this container.
     */
    public var circuit_wire_max_distance: Double? = null
        private set
}

/**
 * A [decider combinator](https://wiki.factorio.com/Decider_combinator).
 */
@Serializable
@SerialName("decider-combinator")
public class DeciderCombinatorPrototype : CombinatorPrototype()

/**
 * Entity with electric energy source with that can have some of its values changed runtime. Useful
 * for modding in energy consumers/producers.
 */
@Serializable
@SerialName("electric-energy-interface")
public class ElectricEnergyInterfacePrototype : EntityWithOwnerPrototype() {
    public lateinit var energy_source: ElectricEnergySource
        private set
}

/**
 * An electric pole - part of the [electric system](https://wiki.factorio.com/Electric_system).
 */
@Serializable
@SerialName("electric-pole")
public class ElectricPolePrototype : EntityWithOwnerPrototype() {
    /**
     * The "radius" of this pole's supply area. Corresponds to *half* of the "supply area" in the
     * item tooltip. If this is 3.5, the pole will have a 7x7 supply area.
     *
     * Max value is 64.
     */
    public var supply_area_distance: Double = 0.0
        private set

    /**
     * The maximum distance between this pole and any other connected pole - if two poles are
     * farther apart than this, they cannot be connected together directly. Corresponds to "wire reach"
     * in the item tooltip.
     *
     * Max value is 64.
     */
    public var maximum_wire_distance: Double? = null
        private set
}

/**
 * A furnace. Normal furnaces only process "smelting" category recipes, but you can make furnaces
 * that process other [recipe categories](prototype:RecipeCategory). The difference to assembling
 * machines is that furnaces automatically choose their recipe based on input.
 */
@Serializable
@SerialName("furnace")
public class FurnacePrototype : CraftingMachinePrototype()

/**
 * A [gate](https://wiki.factorio.com/Gate).
 */
@Serializable
@SerialName("gate")
public class GatePrototype : EntityWithOwnerPrototype()

/**
 * An entity that produces power from fluids, for example a [steam
 * engine](https://wiki.factorio.com/Steam_engine).
 */
@Serializable
@SerialName("generator")
public class GeneratorPrototype : EntityWithOwnerPrototype() {
    public lateinit var energy_source: ElectricEnergySource
        private set

    /**
     * This must have a filter if `max_power_output` is not defined.
     */
    public lateinit var fluid_box: FluidBox
        private set
}

/**
 * This entity produces or consumes heat. Its heat settings can be changed runtime.
 */
@Serializable
@SerialName("heat-interface")
public class HeatInterfacePrototype : EntityWithOwnerPrototype()

/**
 * A [heat pipe](https://wiki.factorio.com/Heat_pipe).
 */
@Serializable
@SerialName("heat-pipe")
public class HeatPipePrototype : EntityWithOwnerPrototype()

/**
 * A generic container, such as a chest, that interacts with the logistics network.
 */
@Serializable
public enum class LogisticMode {
    `active-provider`,
    `passive-provider`,
    requester,
    storage,
    buffer,
}

/**
 * A generic container, such as a chest, that interacts with the logistics network.
 */
@Serializable
@SerialName("logistic-container")
public open class LogisticContainerPrototype : ContainerPrototype() {
    /**
     * The way this chest interacts with the logistic network.
     */
    public var logistic_mode: LogisticMode? = null
        private set

    /**
     * The number of request slots this logistics container has. Requester-type containers must have
     * > 0 slots and can have a maximum of 1000 slots. Storage-type containers must have <= 1 slot.
     */
    public var max_logistic_slots: UShort? = null
        private set
}

/**
 * A generic container, such as a chest, that can spawn or void items and interact with the
 * logistics network.
 */
@Serializable
@SerialName("infinity-container")
public class InfinityContainerPrototype : LogisticContainerPrototype()

/**
 * A [rocket silo](https://wiki.factorio.com/Rocket_silo).
 */
@Serializable
@SerialName("rocket-silo")
public class RocketSiloPrototype : AssemblingMachinePrototype()

/**
 * The abstract base of all [EnergySources](prototype:EnergySource). Specifies the way an entity
 * gets its energy.
 */
@Serializable
public sealed class BaseEnergySource

@Serializable
@SerialName("burner")
public data class BurnerEnergySource(
    /**
     * The energy source can be used with fuel from this [fuel category](prototype:FuelCategory).
     * For a list of built-in categories, see [here](https://wiki.factorio.com/Data.raw#fuel-category).
     *
     * Only loaded if `fuel_categories` is not defined.
     */
    public val fuel_category: FuelCategoryID?,
    /**
     * The energy source can be used with fuel from these [fuel categories](prototype:FuelCategory).
     */
    public val fuel_categories: List<FuelCategoryID>?,
) : BaseEnergySource()

/**
 * Every entry in the array is a specification of one layer the object collides with or a special
 * collision option. Supplying an empty table means that no layers and no collision options are set.
 *
 * The default collision masks of all entity types can be found
 * [here](prototype:EntityPrototype::collision_mask). The base game provides common collision mask
 * functions in a Lua file in the core
 * [lualib](https://github.com/wube/factorio-data/blob/master/core/lualib/collision-mask-util.lua).
 *
 * Supplying an empty array means that no layers and no collision options are set.
 *
 * The three options in addition to the standard layers are not collision masks, instead they
 * control other aspects of collision.
 */
public typealias CollisionMask = List<String>

@Serializable
public enum class EffectType {
    /**
     * Modules that increase or decrease the machine's speed.
     */
    speed,
    /**
     * Modules that make the machine produce bonus items.
     */
    productivity,
    /**
     * Modules that increase or decrease the machine's energy consumption.
     */
    consumption,
    /**
     * Modules that make the machine produce more or less pollution.
     */
    pollution,
}

/**
 * A list of [module](prototype:ModulePrototype) effects, or just a single effect. Modules with
 * other effects cannot be used on the machine. This means that both effects from modules and from
 * surrounding beacons are restricted to the listed effects. If `allowed_effects` is an empty array,
 * the machine cannot be affected by modules or beacons.
 */
public typealias EffectTypeLimitation = ItemOrArray<EffectType>

@Serializable
@SerialName("electric")
public data object ElectricEnergySource : BaseEnergySource(), EVEnergySource

/**
 * Loaded as one of the [BaseEnergySource](prototype:BaseEnergySource) extensions, based on the
 * value of the `type` key.
 */
public typealias EnergySource = BaseEnergySource

@Serializable
public enum class EntityPrototypeFlag {
    /**
     * Can't be rotated before or after placing.
     */
    `not-rotatable`,
    /**
     * Determines the default force when placing entities in the map editor and using the *AUTO*
     * option for the force.
     */
    `placeable-neutral`,
    /**
     * Determines the default force when placing entities in the map editor and using the *AUTO*
     * option for the force.
     */
    `placeable-player`,
    /**
     * Determines the default force when placing entities in the map editor and using the *AUTO*
     * option for the force.
     */
    `placeable-enemy`,
    /**
     * Refers to the fact that most entities are placed on an invisible 'grid' within the world,
     * entities with this flag do not have to line up with this grid (like trees and land-mines).
     */
    `placeable-off-grid`,
    /**
     * Makes it possible for the biter AI to target the entity as a distraction in distraction mode
     * [by_anything](runtime:defines.distraction.by_anything). Makes it possible to blueprint,
     * deconstruct, and repair the entity (can be turned off again using the specific flags). Enables
     * smoke to be created automatically when building the entity. If the entity does not have
     * [EntityPrototype::map_color](prototype:EntityPrototype::map_color) set, this flag makes the
     * entity appear on the map/minimap with the default color specified in the
     * [UtilityConstants](prototype:UtilityConstants).
     */
    `player-creation`,
    /**
     * Uses 45 degree angle increments when selecting direction.
     */
    `building-direction-8-way`,
    /**
     * Used to automatically detect the proper direction, if possible. Used by base with the pump,
     * train stop, and train signal.
     */
    `filter-directions`,
    /**
     * Fast replace will not apply when building while moving.
     */
    `fast-replaceable-no-build-while-moving`,
    /**
     * This is used to specify that the entity breathes air, and so is affected by poison (currently
     * [poison capsules](https://wiki.factorio.com/Poison_capsule) are the only source).
     */
    `breaths-air`,
    /**
     * Used to specify that the entity can not be 'healed' by repair-packs (or construction robots
     * with repair packs)
     */
    `not-repairable`,
    /**
     * The entity does not get drawn on the map.
     */
    `not-on-map`,
    /**
     * The entity can not be deconstructed.
     */
    `not-deconstructable`,
    /**
     * The entity can not be used in blueprints.
     */
    `not-blueprintable`,
    /**
     * Hides the entity from the bonus GUI (button above the map) and from the made in property of
     * recipe tooltips.
     */
    hidden,
    /**
     * Hides the alt-info of an entity in alt-mode, for example the recipe icon.
     */
    `hide-alt-info`,
    /**
     * Do not fast replace over other entity types when building while moving.
     */
    `fast-replaceable-no-cross-type-while-moving`,
    `no-gap-fill-while-building`,
    /**
     * Do not apply fire stickers to the entity.
     */
    `not-flammable`,
    /**
     * Prevents inserters and loaders from taking items from this entity.
     */
    `no-automated-item-removal`,
    /**
     * Prevents inserters and loaders from inserting items into this entity.
     */
    `no-automated-item-insertion`,
    /**
     * This flag does nothing when set in the data stage because it gets overridden by
     * [EntityPrototype::allow_copy_paste](prototype:EntityPrototype::allow_copy_paste). Thus, it must
     * be set on the entity via that property.
     */
    `no-copy-paste`,
    /**
     * Disallows selection of the entity even when a selection box is specified for other reasons.
     * For example, selection boxes are used to determine the size of outlines to be shown when
     * highlighting entities inside electric pole ranges. This flag does nothing when set in the data
     * stage because it gets overridden by
     * [EntityPrototype::selectable_in_game](prototype:EntityPrototype::selectable_in_game). Thus, it
     * must be set on the entity via that property.
     */
    `not-selectable-in-game`,
    /**
     * The entity can't be selected by the [upgrade
     * planner](https://wiki.factorio.com/Upgrade_planner).
     */
    `not-upgradable`,
    /**
     * The entity is not shown in the kill statistics.
     */
    `not-in-kill-statistics`,
    /**
     * The entity is not shown in the made in property of recipe tooltips.
     */
    `not-in-made-in`,
}

/**
 * An array containing the following values.
 *
 * If an entity is a [building](runtime:LuaEntityPrototype::is_building) and has the
 * `"player-creation"` flag set, it is considered for multiple enemy/unit behaviors:
 *
 * - Autonomous enemy attacks (usually triggered by pollution) can only attack within chunks that
 * contain at least one entity that is both a building and a player-creation.
 *
 * - Enemy expansion considers entities that are both buildings and player-creations as "enemy"
 * entities that may block expansion.
 */
public typealias EntityPrototypeFlags = List<EntityPrototypeFlag>

/**
 * Used to set the fluid amount an entity can hold, as well as the connection points for pipes
 * leading into and out of the entity.
 *
 * Entities can have multiple fluidboxes. These can be part of a
 * [FluidEnergySource](prototype:FluidEnergySource), or be specified directly in the entity prototype.
 *
 * A fluidbox can store only one type of fluid at a time. However, a fluid system (ie. multiple
 * connected fluid boxes) can contain multiple different fluids, see [Fluid
 * mixing](https://wiki.factorio.com/Fluid_system#Fluid_mixing).
 */
@Serializable
public data class FluidBox(
    /**
     * Connection points to connect to other fluidboxes. This is also marked as blue arrows in alt
     * mode. Fluid may flow in or out depending on the `type` field of each connection.
     *
     * Connection points may depend on the direction the entity is facing. These connection points
     * cannot share positions with one another or the connection points of another fluid box belonging
     * to the same entity.
     *
     * Can't have more than 255 connections.
     */
    public val pipe_connections: List<PipeConnectionDefinition>,
    /**
     * Can be used to specify which fluid is allowed to enter this fluid box. See
     * [here](https://forums.factorio.com/viewtopic.php?f=28&t=46302).
     */
    public val filter: FluidID?,
    public val production_type: ProductionType?,
)

@Serializable
@SerialName("fluid")
public data class FluidEnergySource(
    /**
     * All standard fluid box configurations are acceptable, but the type must be `"input"` or
     * `"input-output"` to function correctly. `scale_fluid_usage = true`, `fluid_usage_per_tick`, or a
     * filter on the fluidbox must be set to be able to calculate the fluid usage of the energy source.
     */
    public val fluid_box: FluidBox,
) : BaseEnergySource()

/**
 * The name of a [FluidPrototype](prototype:FluidPrototype).
 */
public typealias FluidID = String

/**
 * The name of a [FuelCategory](prototype:FuelCategory).
 */
public typealias FuelCategoryID = String

/**
 * Defines the connections for [HeatEnergySource](prototype:HeatEnergySource) and
 * [HeatBuffer](prototype:HeatBuffer).
 */
@Serializable
public data class HeatConnection(
    /**
     * The location of the heat pipe connection, relative to the center of the entity in the
     * north-facing direction.
     */
    public val position: MapPosition,
    /**
     * The "outward" direction of this heat connection. For a connection to succeed, the other heat
     * connection must face the opposite direction (a south-facing connection needs a north-facing
     * connection to succeed). A connection rotates with the entity.
     */
    public val direction: Direction,
)

@Serializable
@SerialName("heat")
public data class HeatEnergySource(
    /**
     * May contain up to 32 connections.
     */
    public val connections: List<HeatConnection>?,
) : BaseEnergySource()

/**
 * The name of an [ItemPrototype](prototype:ItemPrototype).
 */
public typealias ItemID = String

public typealias ItemStackIndex = UShort

/**
 * Item that when placed creates this entity/tile.
 */
@Serializable
public data class ItemToPlace(
    /**
     * The item used to place this entity/tile.
     */
    public val item: ItemID,
    /**
     * How many items are used to place one of this entity/tile. Can't be larger than the stack size
     * of the item.
     */
    public val count: UInt,
)

/**
 * Coordinates of a tile in a map. Positive x goes towards east, positive y goes towards south, and
 * x is the first dimension in the array format.
 *
 * The coordinates are saved as a fixed-size 32 bit integer, with 8 bits reserved for decimal
 * precision, meaning the smallest value step is `1/2^8 = 0.00390625` tiles.
 */
public typealias MapPosition = Position

/**
 * The number of module slots in this entity, and their icon positions.
 */
@Serializable
public data class ModuleSpecification(
    /**
     * The number of module slots in this entity.
     */
    public val module_slots: ItemStackIndex?,
)

@Serializable
public enum class InputOutputType {
    input,
    `input-output`,
    output,
}

@Serializable
public data class PipeConnectionDefinition(
    /**
     * Where pipes can connect to this fluidbox regardless the directions of entity.
     */
    public val position: Vector?,
    /**
     * Only loaded, and mandatory if `position` is not defined.
     *
     * Where pipes can connect to this fluidbox, depending on the entity direction.
     *
     * Table must have 4 members, which are 4 explicit positions corresponding to the 4 directions
     * of entity. Positions must correspond to directions going one after another.
     */
    public val positions: List<Vector>?,
    /**
     * `0` means not underground.
     */
    public val max_underground_distance: UInt?,
    public val type: InputOutputType?,
)

@Serializable
public enum class ProductionType {
    None,
    none,
    input,
    `input-output`,
    output,
}

/**
 * The name of a [RecipeCategory](prototype:RecipeCategory).
 */
public typealias RecipeCategoryID = String

/**
 * The name of a [RecipePrototype](prototype:RecipePrototype).
 */
public typealias RecipeID = String

@Serializable
public enum class SignalType {
    virtual,
    item,
    fluid,
}

@Serializable
public data class SignalIDConnector(
    public val type: SignalType,
    /**
     * Name of the signal that shows this color.
     */
    public val name: String,
)

/**
 * A vector is a two-element array or dictionary containing the x and y components. Positive x goes
 * east, positive y goes south.
 */
public typealias Vector = Position

/**
 * Void energy sources provide unlimited free energy.
 */
@Serializable
@SerialName("void")
public data object VoidEnergySource : BaseEnergySource(), EVEnergySource

@Serializable
public sealed interface EVEnergySource

/**
 * All prototypes, aka [data.raw](https://wiki.factorio.com/Data.raw). Only contains the subset of
 * objects this library uses.
 */
@Serializable
public class DataRaw(
    public val accumulator: Map<String, AccumulatorPrototype>,
    public val `artillery-turret`: Map<String, ArtilleryTurretPrototype>,
    public val beacon: Map<String, BeaconPrototype>,
    public val boiler: Map<String, BoilerPrototype>,
    public val `burner-generator`: Map<String, BurnerGeneratorPrototype>,
    public val `arithmetic-combinator`: Map<String, ArithmeticCombinatorPrototype>,
    public val `decider-combinator`: Map<String, DeciderCombinatorPrototype>,
    public val `constant-combinator`: Map<String, ConstantCombinatorPrototype>,
    public val container: Map<String, ContainerPrototype>,
    public val `logistic-container`: Map<String, LogisticContainerPrototype>,
    public val `infinity-container`: Map<String, InfinityContainerPrototype>,
    public val `assembling-machine`: Map<String, AssemblingMachinePrototype>,
    public val `rocket-silo`: Map<String, RocketSiloPrototype>,
    public val furnace: Map<String, FurnacePrototype>,
    public val `electric-energy-interface`: Map<String, ElectricEnergyInterfacePrototype>,
    public val `electric-pole`: Map<String, ElectricPolePrototype>,
    public val gate: Map<String, GatePrototype>,
    public val generator: Map<String, GeneratorPrototype>,
    public val `heat-interface`: Map<String, HeatInterfacePrototype>,
    public val `heat-pipe`: Map<String, HeatPipePrototype>,
)
